diff --git a/include/mpark/variant.hpp b/include/mpark/variant.hpp
index 2fb2ac549..962ff3f59 100644
--- a/include/mpark/variant.hpp
+++ b/include/mpark/variant.hpp
@@ -244,9 +244,11 @@ namespace mpark {
     virtual const char *what() const noexcept override { return "bad_variant_access"; }
   };
 
-  [[noreturn]] inline void throw_bad_variant_access() {
+  //[[noreturn]]
+  KOKKOS_INLINE_FUNCTION void throw_bad_variant_access() {
 #ifdef MPARK_EXCEPTIONS
-    throw bad_variant_access{};
+    //throw bad_variant_access{};
+    return;
 #else
     std::terminate();
     MPARK_BUILTIN_UNREACHABLE;
@@ -310,7 +312,7 @@ namespace mpark {
 
 #ifdef MPARK_CPP14_CONSTEXPR
     template <typename T, typename... Ts>
-    inline constexpr std::size_t find_index() {
+    KOKKOS_INLINE_FUNCTION constexpr std::size_t find_index() {
       constexpr lib::array<bool, sizeof...(Ts)> matches = {
           {std::is_same<T, Ts>::value...}
       };
@@ -326,13 +328,13 @@ namespace mpark {
       return result;
     }
 #else
-    inline constexpr std::size_t find_index_impl(std::size_t result,
+    KOKKOS_INLINE_FUNCTION constexpr std::size_t find_index_impl(std::size_t result,
                                                  std::size_t) {
       return result;
     }
 
     template <typename... Bs>
-    inline constexpr std::size_t find_index_impl(std::size_t result,
+    KOKKOS_INLINE_FUNCTION constexpr std::size_t find_index_impl(std::size_t result,
                                                  std::size_t idx,
                                                  bool b,
                                                  Bs... bs) {
@@ -342,7 +344,7 @@ namespace mpark {
     }
 
     template <typename T, typename... Ts>
-    inline constexpr std::size_t find_index() {
+    KOKKOS_INLINE_FUNCTION constexpr std::size_t find_index() {
       return find_index_impl(not_found, 0, std::is_same<T, Ts>::value...);
     }
 #endif
@@ -371,7 +373,7 @@ namespace mpark {
     template <typename T,
               template <typename> class IsTriviallyAvailable,
               template <typename> class IsAvailable>
-    inline constexpr Trait trait() {
+    KOKKOS_INLINE_FUNCTION constexpr Trait trait() {
       return IsTriviallyAvailable<T>::value
                  ? Trait::TriviallyAvailable
                  : IsAvailable<T>::value ? Trait::Available
@@ -380,7 +382,7 @@ namespace mpark {
 
 #ifdef MPARK_CPP14_CONSTEXPR
     template <typename... Traits>
-    inline constexpr Trait common_trait(Traits... traits_) {
+    KOKKOS_INLINE_FUNCTION constexpr Trait common_trait(Traits... traits_) {
       Trait result = Trait::TriviallyAvailable;
       lib::array<Trait, sizeof...(Traits)> traits = {{traits_...}};
       for (std::size_t i = 0; i < sizeof...(Traits); ++i) {
@@ -392,10 +394,10 @@ namespace mpark {
       return result;
     }
 #else
-    inline constexpr Trait common_trait_impl(Trait result) { return result; }
+    KOKKOS_INLINE_FUNCTION constexpr Trait common_trait_impl(Trait result) { return result; }
 
     template <typename... Traits>
-    inline constexpr Trait common_trait_impl(Trait result,
+    KOKKOS_INLINE_FUNCTION constexpr Trait common_trait_impl(Trait result,
                                              Trait t,
                                              Traits... ts) {
       return static_cast<int>(t) > static_cast<int>(result)
@@ -404,7 +406,7 @@ namespace mpark {
     }
 
     template <typename... Traits>
-    inline constexpr Trait common_trait(Traits... ts) {
+    KOKKOS_INLINE_FUNCTION constexpr Trait common_trait(Traits... ts) {
       return common_trait_impl(Trait::TriviallyAvailable, ts...);
     }
 #endif
@@ -444,38 +446,38 @@ namespace mpark {
       struct recursive_union {
 #ifdef MPARK_RETURN_TYPE_DEDUCTION
         template <typename V>
-        inline static constexpr auto &&get_alt(V &&v, in_place_index_t<0>) {
+        KOKKOS_INLINE_FUNCTION static constexpr auto &&get_alt(V &&v, in_place_index_t<0>) {
           return lib::forward<V>(v).head_;
         }
 
         template <typename V, std::size_t I>
-        inline static constexpr auto &&get_alt(V &&v, in_place_index_t<I>) {
+        KOKKOS_INLINE_FUNCTION static constexpr auto &&get_alt(V &&v, in_place_index_t<I>) {
           return get_alt(lib::forward<V>(v).tail_, in_place_index_t<I - 1>{});
         }
 #else
         template <std::size_t I, bool Dummy = true>
         struct get_alt_impl {
           template <typename V>
-          inline constexpr AUTO_REFREF operator()(V &&v) const
+          KOKKOS_INLINE_FUNCTION constexpr AUTO_REFREF operator()(V &&v) const
             AUTO_REFREF_RETURN(get_alt_impl<I - 1>{}(lib::forward<V>(v).tail_))
         };
 
         template <bool Dummy>
         struct get_alt_impl<0, Dummy> {
           template <typename V>
-          inline constexpr AUTO_REFREF operator()(V &&v) const
+          KOKKOS_INLINE_FUNCTION constexpr AUTO_REFREF operator()(V &&v) const
             AUTO_REFREF_RETURN(lib::forward<V>(v).head_)
         };
 
         template <typename V, std::size_t I>
-        inline static constexpr AUTO_REFREF get_alt(V &&v, in_place_index_t<I>)
+        KOKKOS_INLINE_FUNCTION static constexpr AUTO_REFREF get_alt(V &&v, in_place_index_t<I>)
           AUTO_REFREF_RETURN(get_alt_impl<I>{}(lib::forward<V>(v)))
 #endif
       };
 
       struct base {
         template <std::size_t I, typename V>
-        inline static constexpr AUTO_REFREF get_alt(V &&v)
+        KOKKOS_INLINE_FUNCTION static constexpr AUTO_REFREF get_alt(V &&v)
 #ifdef _MSC_VER
           AUTO_REFREF_RETURN(recursive_union::get_alt(
               lib::forward<V>(v).data_, in_place_index_t<I>{}))
@@ -487,7 +489,7 @@ namespace mpark {
 
       struct variant {
         template <std::size_t I, typename V>
-        inline static constexpr AUTO_REFREF get_alt(V &&v)
+        KOKKOS_INLINE_FUNCTION static constexpr AUTO_REFREF get_alt(V &&v)
           AUTO_REFREF_RETURN(base::get_alt<I>(lib::forward<V>(v).impl_))
       };
 
@@ -508,7 +510,7 @@ namespace mpark {
         template <typename Expected>
         struct expected {
           template <typename Actual>
-          inline static constexpr bool but_got() {
+          KOKKOS_INLINE_FUNCTION static constexpr bool but_got() {
             return std::is_same<Expected, Actual>::value;
           }
         };
@@ -520,7 +522,7 @@ namespace mpark {
               "`visit` requires the visitor to have a single return type");
 
           template <typename Visitor, typename... Alts>
-          inline static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
+          KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
                                                        Alts &&... alts)
             DECLTYPE_AUTO_RETURN(lib::invoke(lib::forward<Visitor>(visitor),
                                              lib::forward<Alts>(alts)...))
@@ -697,18 +699,18 @@ namespace mpark {
         };
 #else
         template <typename T>
-        inline static constexpr const T &at(const T &elem) noexcept {
+        KOKKOS_INLINE_FUNCTION static constexpr const T &at(const T &elem) noexcept {
           return elem;
         }
 
         template <typename T, std::size_t N, typename... Is>
-        inline static constexpr const lib::remove_all_extents_t<T> &at(
+        KOKKOS_INLINE_FUNCTION static constexpr const lib::remove_all_extents_t<T> &at(
             const lib::array<T, N> &elems, std::size_t i, Is... is) noexcept {
           return at(elems[i], is...);
         }
 
         template <typename F, typename... Fs>
-        inline static constexpr lib::array<lib::decay_t<F>, sizeof...(Fs) + 1>
+        KOKKOS_INLINE_FUNCTION static constexpr lib::array<lib::decay_t<F>, sizeof...(Fs) + 1>
         make_farray(F &&f, Fs &&... fs) {
           return {{lib::forward<F>(f), lib::forward<Fs>(fs)...}};
         }
@@ -717,7 +719,7 @@ namespace mpark {
         struct make_fmatrix_impl {
 
           template <std::size_t... Is>
-          inline static constexpr dispatch_result_t<F, Vs...> dispatch(
+          KOKKOS_INLINE_FUNCTION static constexpr dispatch_result_t<F, Vs...> dispatch(
               F &&f, Vs &&... vs) {
             using Expected = dispatch_result_t<F, Vs...>;
             using Actual = decltype(lib::invoke(
@@ -730,12 +732,12 @@ namespace mpark {
 
 #ifdef MPARK_RETURN_TYPE_DEDUCTION
           template <std::size_t... Is>
-          inline static constexpr auto impl(lib::index_sequence<Is...>) {
+          KOKKOS_INLINE_FUNCTION static constexpr auto impl(lib::index_sequence<Is...>) {
             return &dispatch<Is...>;
           }
 
           template <typename Is, std::size_t... Js, typename... Ls>
-          inline static constexpr auto impl(Is,
+          KOKKOS_INLINE_FUNCTION static constexpr auto impl(Is,
                                             lib::index_sequence<Js...>,
                                             Ls... ls) {
             return make_farray(impl(lib::push_back_t<Is, Js>{}, ls...)...);
@@ -746,13 +748,13 @@ namespace mpark {
 
           template <std::size_t... Is>
           struct impl<lib::index_sequence<Is...>> {
-            inline constexpr AUTO operator()() const
+            KOKKOS_INLINE_FUNCTION constexpr AUTO operator()() const
               AUTO_RETURN(&dispatch<Is...>)
           };
 
           template <typename Is, std::size_t... Js, typename... Ls>
           struct impl<Is, lib::index_sequence<Js...>, Ls...> {
-            inline constexpr AUTO operator()() const
+            KOKKOS_INLINE_FUNCTION constexpr AUTO operator()() const
               AUTO_RETURN(
                   make_farray(impl<lib::push_back_t<Is, Js>, Ls...>{}()...))
           };
@@ -761,14 +763,14 @@ namespace mpark {
 
 #ifdef MPARK_RETURN_TYPE_DEDUCTION
         template <typename F, typename... Vs>
-        inline static constexpr auto make_fmatrix() {
+        KOKKOS_INLINE_FUNCTION static constexpr auto make_fmatrix() {
           return make_fmatrix_impl<F, Vs...>::impl(
               lib::index_sequence<>{},
               lib::make_index_sequence<lib::decay_t<Vs>::size()>{}...);
         }
 #else
         template <typename F, typename... Vs>
-        inline static constexpr AUTO make_fmatrix()
+        KOKKOS_INLINE_FUNCTION static constexpr AUTO make_fmatrix()
           AUTO_RETURN(
               typename make_fmatrix_impl<F, Vs...>::template impl<
                   lib::index_sequence<>,
@@ -778,7 +780,7 @@ namespace mpark {
         template <typename F, typename... Vs>
         struct make_fdiagonal_impl {
           template <std::size_t I>
-          inline static constexpr dispatch_result_t<F, Vs...> dispatch(
+          KOKKOS_INLINE_FUNCTION static constexpr dispatch_result_t<F, Vs...> dispatch(
               F &&f, Vs &&... vs) {
             using Expected = dispatch_result_t<F, Vs...>;
             using Actual = decltype(
@@ -790,12 +792,12 @@ namespace mpark {
           }
 
           template <std::size_t... Is>
-          inline static constexpr AUTO impl(lib::index_sequence<Is...>)
+          KOKKOS_INLINE_FUNCTION static constexpr AUTO impl(lib::index_sequence<Is...>)
             AUTO_RETURN(make_farray(&dispatch<Is>...))
         };
 
         template <typename F, typename V, typename... Vs>
-        inline static constexpr auto make_fdiagonal()
+        KOKKOS_INLINE_FUNCTION static constexpr auto make_fdiagonal()
             -> decltype(make_fdiagonal_impl<F, V, Vs...>::impl(
                 lib::make_index_sequence<lib::decay_t<V>::size()>{})) {
           static_assert(lib::all<(lib::decay_t<V>::size() ==
@@ -836,7 +838,7 @@ namespace mpark {
 
       struct alt {
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
                                                         Vs &&... vs)
 #ifdef MPARK_VARIANT_SWITCH_VISIT
           DECLTYPE_AUTO_RETURN(
@@ -862,7 +864,7 @@ namespace mpark {
 #endif
 
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
                                                            Visitor &&visitor,
                                                            Vs &&... vs)
 #ifdef MPARK_VARIANT_SWITCH_VISIT
@@ -895,7 +897,7 @@ namespace mpark {
         template <typename Visitor>
         struct visitor {
           template <typename... Values>
-          inline static constexpr bool does_not_handle() {
+          KOKKOS_INLINE_FUNCTION static constexpr bool does_not_handle() {
             return lib::is_invocable<Visitor, Values...>::value;
           }
         };
@@ -905,7 +907,7 @@ namespace mpark {
           static_assert(visitor<Visitor>::template does_not_handle<Values...>(),
                         "`visit` requires the visitor to be exhaustive.");
 
-          inline static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
+          KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO invoke(Visitor &&visitor,
                                                        Values &&... values)
             DECLTYPE_AUTO_RETURN(lib::invoke(lib::forward<Visitor>(visitor),
                                              lib::forward<Values>(values)...))
@@ -916,7 +918,7 @@ namespace mpark {
           Visitor &&visitor_;
 
           template <typename... Alts>
-          inline constexpr DECLTYPE_AUTO operator()(Alts &&... alts) const
+          KOKKOS_INLINE_FUNCTION constexpr DECLTYPE_AUTO operator()(Alts &&... alts) const
             DECLTYPE_AUTO_RETURN(
                 visit_exhaustiveness_check<
                     Visitor,
@@ -926,18 +928,18 @@ namespace mpark {
         };
 
         template <typename Visitor>
-        inline static constexpr AUTO make_value_visitor(Visitor &&visitor)
+        KOKKOS_INLINE_FUNCTION static constexpr AUTO make_value_visitor(Visitor &&visitor)
           AUTO_RETURN(value_visitor<Visitor>{lib::forward<Visitor>(visitor)})
 
         public:
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_alt(Visitor &&visitor,
                                                         Vs &&... vs)
           DECLTYPE_AUTO_RETURN(alt::visit_alt(lib::forward<Visitor>(visitor),
                                               lib::forward<Vs>(vs).impl_...))
 
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_alt_at(std::size_t index,
                                                            Visitor &&visitor,
                                                            Vs &&... vs)
           DECLTYPE_AUTO_RETURN(
@@ -946,14 +948,14 @@ namespace mpark {
                                 lib::forward<Vs>(vs).impl_...))
 
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_value(Visitor &&visitor,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_value(Visitor &&visitor,
                                                           Vs &&... vs)
           DECLTYPE_AUTO_RETURN(
               visit_alt(make_value_visitor(lib::forward<Visitor>(visitor)),
                         lib::forward<Vs>(vs)...))
 
         template <typename Visitor, typename... Vs>
-        inline static constexpr DECLTYPE_AUTO visit_value_at(std::size_t index,
+        KOKKOS_INLINE_FUNCTION static constexpr DECLTYPE_AUTO visit_value_at(std::size_t index,
                                                              Visitor &&visitor,
                                                              Vs &&... vs)
           DECLTYPE_AUTO_RETURN(
@@ -973,7 +975,7 @@ namespace mpark {
 #pragma warning(disable : 4244)
 #endif
       template <typename... Args>
-      inline explicit constexpr alt(in_place_t, Args &&... args)
+      KOKKOS_INLINE_FUNCTION explicit constexpr alt(in_place_t, Args &&... args)
           : value(lib::forward<Args>(args)...) {}
 #ifdef _MSC_VER
 #pragma warning(pop)
@@ -992,16 +994,16 @@ namespace mpark {
   template <std::size_t Index, typename T, typename... Ts>                 \
   union recursive_union<destructible_trait, Index, T, Ts...> {             \
     public:                                                                \
-    inline explicit constexpr recursive_union(valueless_t) noexcept        \
+    KOKKOS_INLINE_FUNCTION explicit constexpr recursive_union(valueless_t) noexcept        \
         : dummy_{} {}                                                      \
                                                                            \
     template <typename... Args>                                            \
-    inline explicit constexpr recursive_union(in_place_index_t<0>,         \
+    KOKKOS_INLINE_FUNCTION explicit constexpr recursive_union(in_place_index_t<0>,         \
                                               Args &&... args)             \
         : head_(in_place_t{}, lib::forward<Args>(args)...) {}              \
                                                                            \
     template <std::size_t I, typename... Args>                             \
-    inline explicit constexpr recursive_union(in_place_index_t<I>,         \
+    KOKKOS_INLINE_FUNCTION explicit constexpr recursive_union(in_place_index_t<I>,         \
                                               Args &&... args)             \
         : tail_(in_place_index_t<I - 1>{}, lib::forward<Args>(args)...) {} \
                                                                            \
@@ -1043,36 +1045,36 @@ namespace mpark {
     template <Trait DestructibleTrait, typename... Ts>
     class base {
       public:
-      inline explicit constexpr base(valueless_t tag) noexcept
+      KOKKOS_INLINE_FUNCTION explicit constexpr base(valueless_t tag) noexcept
           : data_(tag), index_(static_cast<index_t<Ts...>>(-1)) {}
 
       template <std::size_t I, typename... Args>
-      inline explicit constexpr base(in_place_index_t<I>, Args &&... args)
+      KOKKOS_INLINE_FUNCTION explicit constexpr base(in_place_index_t<I>, Args &&... args)
           : data_(in_place_index_t<I>{}, lib::forward<Args>(args)...),
             index_(I) {}
 
-      inline constexpr bool valueless_by_exception() const noexcept {
+      KOKKOS_INLINE_FUNCTION constexpr bool valueless_by_exception() const noexcept {
         return index_ == static_cast<index_t<Ts...>>(-1);
       }
 
-      inline constexpr std::size_t index() const noexcept {
+      KOKKOS_INLINE_FUNCTION constexpr std::size_t index() const noexcept {
         return valueless_by_exception() ? variant_npos : index_;
       }
 
       protected:
       using data_t = recursive_union<DestructibleTrait, 0, Ts...>;
 
-      friend inline constexpr base &as_base(base &b) { return b; }
-      friend inline constexpr const base &as_base(const base &b) { return b; }
-      friend inline constexpr base &&as_base(base &&b) { return lib::move(b); }
-      friend inline constexpr const base &&as_base(const base &&b) { return lib::move(b); }
+      friend KOKKOS_INLINE_FUNCTION constexpr base &as_base(base &b) { return b; }
+      friend KOKKOS_INLINE_FUNCTION constexpr const base &as_base(const base &b) { return b; }
+      friend KOKKOS_INLINE_FUNCTION constexpr base &&as_base(base &&b) { return lib::move(b); }
+      friend KOKKOS_INLINE_FUNCTION constexpr const base &&as_base(const base &&b) { return lib::move(b); }
 
-      friend inline constexpr data_t &data(base &b) { return b.data_; }
-      friend inline constexpr const data_t &data(const base &b) { return b.data_; }
-      friend inline constexpr data_t &&data(base &&b) { return lib::move(b).data_; }
-      friend inline constexpr const data_t &&data(const base &&b) { return lib::move(b).data_; }
+      friend KOKKOS_INLINE_FUNCTION constexpr data_t &data(base &b) { return b.data_; }
+      friend KOKKOS_INLINE_FUNCTION constexpr const data_t &data(const base &b) { return b.data_; }
+      friend KOKKOS_INLINE_FUNCTION constexpr data_t &&data(base &&b) { return lib::move(b).data_; }
+      friend KOKKOS_INLINE_FUNCTION constexpr const data_t &&data(const base &&b) { return lib::move(b).data_; }
 
-      inline static constexpr std::size_t size() { return sizeof...(Ts); }
+      KOKKOS_INLINE_FUNCTION static constexpr std::size_t size() { return sizeof...(Ts); }
 
       data_t data_;
       index_t<Ts...> index_;
@@ -1087,7 +1089,7 @@ namespace mpark {
 #pragma warning(disable : 4100)
 #endif
       template <typename Alt>
-      inline void operator()(Alt &alt) const noexcept { alt.~Alt(); }
+      KOKKOS_INLINE_FUNCTION void operator()(Alt &alt) const noexcept { alt.~Alt(); }
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
@@ -1098,7 +1100,7 @@ namespace mpark {
 #else
 #define MPARK_INHERITING_CTOR(type, base)         \
   template <typename... Args>                     \
-  inline explicit constexpr type(Args &&... args) \
+  KOKKOS_INLINE_FUNCTION explicit constexpr type(Args &&... args) \
       : base(lib::forward<Args>(args)...) {}
 #endif
 
@@ -1128,14 +1130,14 @@ namespace mpark {
     MPARK_VARIANT_DESTRUCTOR(
         Trait::TriviallyAvailable,
         ~destructor() = default;,
-        inline void destroy() noexcept {
+        KOKKOS_INLINE_FUNCTION void destroy() noexcept {
           this->index_ = static_cast<index_t<Ts...>>(-1);
         });
 
     MPARK_VARIANT_DESTRUCTOR(
         Trait::Available,
         ~destructor() { destroy(); },
-        inline void destroy() noexcept {
+        KOKKOS_INLINE_FUNCTION void destroy() noexcept {
           if (!this->valueless_by_exception()) {
             visitation::alt::visit_alt(dtor{}, *this);
           }
@@ -1145,7 +1147,7 @@ namespace mpark {
     MPARK_VARIANT_DESTRUCTOR(
         Trait::Unavailable,
         ~destructor() = delete;,
-        inline void destroy() noexcept = delete;);
+        KOKKOS_INLINE_FUNCTION void destroy() noexcept = delete;);
 
 #undef MPARK_VARIANT_DESTRUCTOR
 
@@ -1161,7 +1163,7 @@ namespace mpark {
 #ifndef MPARK_GENERIC_LAMBDAS
       struct ctor {
         template <typename LhsAlt, typename RhsAlt>
-        inline void operator()(LhsAlt &lhs_alt, RhsAlt &&rhs_alt) const {
+        KOKKOS_INLINE_FUNCTION void operator()(LhsAlt &lhs_alt, RhsAlt &&rhs_alt) const {
           constructor::construct_alt(lhs_alt,
                                      lib::forward<RhsAlt>(rhs_alt).value);
         }
@@ -1169,14 +1171,14 @@ namespace mpark {
 #endif
 
       template <std::size_t I, typename T, typename... Args>
-      inline static T &construct_alt(alt<I, T> &a, Args &&... args) {
+      KOKKOS_INLINE_FUNCTION static T &construct_alt(alt<I, T> &a, Args &&... args) {
         auto *result = ::new (static_cast<void *>(lib::addressof(a)))
             alt<I, T>(in_place_t{}, lib::forward<Args>(args)...);
         return result->value;
       }
 
       template <typename Rhs>
-      inline static void generic_construct(constructor &lhs, Rhs &&rhs) {
+      KOKKOS_INLINE_FUNCTION static void generic_construct(constructor &lhs, Rhs &&rhs) {
         lhs.destroy();
         if (!rhs.valueless_by_exception()) {
           visitation::alt::visit_alt_at(
@@ -1281,7 +1283,7 @@ namespace mpark {
       using super::operator=;
 
       template <std::size_t I, typename... Args>
-      inline /* auto & */ auto emplace(Args &&... args)
+      KOKKOS_INLINE_FUNCTION /* auto & */ auto emplace(Args &&... args)
           -> decltype(this->construct_alt(access::base::get_alt<I>(*this),
                                           lib::forward<Args>(args)...)) {
         this->destroy();
@@ -1296,7 +1298,7 @@ namespace mpark {
       template <typename That>
       struct assigner {
         template <typename ThisAlt, typename ThatAlt>
-        inline void operator()(ThisAlt &this_alt, ThatAlt &&that_alt) const {
+        KOKKOS_INLINE_FUNCTION void operator()(ThisAlt &this_alt, ThatAlt &&that_alt) const {
           self->assign_alt(this_alt, lib::forward<ThatAlt>(that_alt).value);
         }
         assignment *self;
@@ -1304,7 +1306,7 @@ namespace mpark {
 #endif
 
       template <std::size_t I, typename T, typename Arg>
-      inline void assign_alt(alt<I, T> &a, Arg &&arg) {
+      KOKKOS_INLINE_FUNCTION void assign_alt(alt<I, T> &a, Arg &&arg) {
         if (this->index() == I) {
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1332,7 +1334,7 @@ namespace mpark {
       }
 
       template <typename That>
-      inline void generic_assign(That &&that) {
+      KOKKOS_INLINE_FUNCTION void generic_assign(That &&that) {
         if (this->valueless_by_exception() && that.valueless_by_exception()) {
           // do nothing.
         } else if (that.valueless_by_exception()) {
@@ -1447,12 +1449,12 @@ namespace mpark {
       impl &operator=(impl &&) = default;
 
       template <std::size_t I, typename Arg>
-      inline void assign(Arg &&arg) {
+      KOKKOS_INLINE_FUNCTION void assign(Arg &&arg) {
         this->assign_alt(access::base::get_alt<I>(*this),
                          lib::forward<Arg>(arg));
       }
 
-      inline void swap(impl &that) {
+      KOKKOS_INLINE_FUNCTION void swap(impl &that) {
         if (this->valueless_by_exception() && that.valueless_by_exception()) {
           // do nothing.
         } else if (this->index() == that.index()) {
@@ -1499,14 +1501,14 @@ namespace mpark {
 #ifndef MPARK_GENERIC_LAMBDAS
       struct swapper {
         template <typename ThisAlt, typename ThatAlt>
-        inline void operator()(ThisAlt &this_alt, ThatAlt &that_alt) const {
+        KOKKOS_INLINE_FUNCTION void operator()(ThisAlt &this_alt, ThatAlt &that_alt) const {
           using std::swap;
           swap(this_alt.value, that_alt.value);
         }
       };
 #endif
 
-      inline constexpr bool move_nothrow() const {
+      KOKKOS_INLINE_FUNCTION constexpr bool move_nothrow() const {
         return this->valueless_by_exception() ||
                lib::array<bool, sizeof...(Ts)>{
                    {std::is_nothrow_move_constructible<Ts>::value...}
@@ -1612,7 +1614,7 @@ namespace mpark {
     template <
         typename Front = lib::type_pack_element_t<0, Ts...>,
         lib::enable_if_t<std::is_default_constructible<Front>::value, int> = 0>
-    inline constexpr variant() noexcept(
+    KOKKOS_INLINE_FUNCTION constexpr variant() noexcept(
         std::is_nothrow_default_constructible<Front>::value)
         : impl_(in_place_index_t<0>{}) {}
 
@@ -1628,7 +1630,7 @@ namespace mpark {
         std::size_t I = detail::best_match<Arg, Ts...>::value,
         typename T = lib::type_pack_element_t<I, Ts...>,
         lib::enable_if_t<std::is_constructible<T, Arg>::value, int> = 0>
-    inline constexpr variant(Arg &&arg) noexcept(
+    KOKKOS_INLINE_FUNCTION constexpr variant(Arg &&arg) noexcept(
         std::is_nothrow_constructible<T, Arg>::value)
         : impl_(in_place_index_t<I>{}, lib::forward<Arg>(arg)) {}
 
@@ -1637,7 +1639,7 @@ namespace mpark {
         typename... Args,
         typename T = lib::type_pack_element_t<I, Ts...>,
         lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
-    inline explicit constexpr variant(
+    KOKKOS_INLINE_FUNCTION explicit constexpr variant(
         in_place_index_t<I>,
         Args &&... args) noexcept(std::is_nothrow_constructible<T,
                                                                 Args...>::value)
@@ -1652,7 +1654,7 @@ namespace mpark {
                                                std::initializer_list<Up> &,
                                                Args...>::value,
                          int> = 0>
-    inline explicit constexpr variant(
+    KOKKOS_INLINE_FUNCTION explicit constexpr variant(
         in_place_index_t<I>,
         std::initializer_list<Up> il,
         Args &&... args) noexcept(std::
@@ -1667,7 +1669,7 @@ namespace mpark {
         typename... Args,
         std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
         lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
-    inline explicit constexpr variant(
+    KOKKOS_INLINE_FUNCTION explicit constexpr variant(
         in_place_type_t<T>,
         Args &&... args) noexcept(std::is_nothrow_constructible<T,
                                                                 Args...>::value)
@@ -1682,7 +1684,7 @@ namespace mpark {
                                                std::initializer_list<Up> &,
                                                Args...>::value,
                          int> = 0>
-    inline explicit constexpr variant(
+    KOKKOS_INLINE_FUNCTION explicit constexpr variant(
         in_place_type_t<T>,
         std::initializer_list<Up> il,
         Args &&... args) noexcept(std::
@@ -1705,7 +1707,7 @@ namespace mpark {
               lib::enable_if_t<(std::is_assignable<T &, Arg>::value &&
                                 std::is_constructible<T, Arg>::value),
                                int> = 0>
-    inline variant &operator=(Arg &&arg) noexcept(
+    KOKKOS_INLINE_FUNCTION variant &operator=(Arg &&arg) noexcept(
         (std::is_nothrow_assignable<T &, Arg>::value &&
          std::is_nothrow_constructible<T, Arg>::value)) {
       impl_.template assign<I>(lib::forward<Arg>(arg));
@@ -1717,7 +1719,7 @@ namespace mpark {
         typename... Args,
         typename T = lib::type_pack_element_t<I, Ts...>,
         lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
-    inline T &emplace(Args &&... args) {
+    KOKKOS_INLINE_FUNCTION T &emplace(Args &&... args) {
       return impl_.template emplace<I>(lib::forward<Args>(args)...);
     }
 
@@ -1730,7 +1732,7 @@ namespace mpark {
                                                std::initializer_list<Up> &,
                                                Args...>::value,
                          int> = 0>
-    inline T &emplace(std::initializer_list<Up> il, Args &&... args) {
+    KOKKOS_INLINE_FUNCTION T &emplace(std::initializer_list<Up> il, Args &&... args) {
       return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
     }
 
@@ -1739,7 +1741,7 @@ namespace mpark {
         typename... Args,
         std::size_t I = detail::find_index_sfinae<T, Ts...>::value,
         lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
-    inline T &emplace(Args &&... args) {
+    KOKKOS_INLINE_FUNCTION T &emplace(Args &&... args) {
       return impl_.template emplace<I>(lib::forward<Args>(args)...);
     }
 
@@ -1752,15 +1754,15 @@ namespace mpark {
                                                std::initializer_list<Up> &,
                                                Args...>::value,
                          int> = 0>
-    inline T &emplace(std::initializer_list<Up> il, Args &&... args) {
+    KOKKOS_INLINE_FUNCTION T &emplace(std::initializer_list<Up> il, Args &&... args) {
       return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
     }
 
-    inline constexpr bool valueless_by_exception() const noexcept {
+    KOKKOS_INLINE_FUNCTION constexpr bool valueless_by_exception() const noexcept {
       return impl_.valueless_by_exception();
     }
 
-    inline constexpr std::size_t index() const noexcept {
+    KOKKOS_INLINE_FUNCTION constexpr std::size_t index() const noexcept {
       return impl_.index();
     }
 
@@ -1772,7 +1774,7 @@ namespace mpark {
                             lib::dependent_type<lib::is_swappable<Ts>,
                                                 Dummy>::value)...>::value,
                   int> = 0>
-    inline void swap(variant &that) noexcept(
+    KOKKOS_INLINE_FUNCTION void swap(variant &that) noexcept(
         lib::all<(std::is_nothrow_move_constructible<Ts>::value &&
                   lib::is_nothrow_swappable<Ts>::value)...>::value) {
       impl_.swap(that.impl_);
@@ -1786,12 +1788,12 @@ namespace mpark {
   };
 
   template <std::size_t I, typename... Ts>
-  inline constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
     return v.index() == I;
   }
 
   template <typename T, typename... Ts>
-  inline constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool holds_alternative(const variant<Ts...> &v) noexcept {
     return holds_alternative<detail::find_index_checked<T, Ts...>::value>(v);
   }
 
@@ -1806,60 +1808,60 @@ namespace mpark {
     };
 
     template <std::size_t I, typename V>
-    inline constexpr AUTO_REFREF generic_get(V &&v)
+    KOKKOS_INLINE_FUNCTION constexpr AUTO_REFREF generic_get(V &&v)
       AUTO_REFREF_RETURN(generic_get_impl<I, V>(
           holds_alternative<I>(v) ? 0 : (throw_bad_variant_access(), 0))(
           lib::forward<V>(v)))
   }  // namespace detail
 
   template <std::size_t I, typename... Ts>
-  inline constexpr variant_alternative_t<I, variant<Ts...>> &get(
+  KOKKOS_INLINE_FUNCTION constexpr variant_alternative_t<I, variant<Ts...>> &get(
       variant<Ts...> &v) {
     return detail::generic_get<I>(v);
   }
 
   template <std::size_t I, typename... Ts>
-  inline constexpr variant_alternative_t<I, variant<Ts...>> &&get(
+  KOKKOS_INLINE_FUNCTION constexpr variant_alternative_t<I, variant<Ts...>> &&get(
       variant<Ts...> &&v) {
     return detail::generic_get<I>(lib::move(v));
   }
 
   template <std::size_t I, typename... Ts>
-  inline constexpr const variant_alternative_t<I, variant<Ts...>> &get(
+  KOKKOS_INLINE_FUNCTION constexpr const variant_alternative_t<I, variant<Ts...>> &get(
       const variant<Ts...> &v) {
     return detail::generic_get<I>(v);
   }
 
   template <std::size_t I, typename... Ts>
-  inline constexpr const variant_alternative_t<I, variant<Ts...>> &&get(
+  KOKKOS_INLINE_FUNCTION constexpr const variant_alternative_t<I, variant<Ts...>> &&get(
       const variant<Ts...> &&v) {
     return detail::generic_get<I>(lib::move(v));
   }
 
   template <typename T, typename... Ts>
-  inline constexpr T &get(variant<Ts...> &v) {
+  KOKKOS_INLINE_FUNCTION constexpr T &get(variant<Ts...> &v) {
     return get<detail::find_index_checked<T, Ts...>::value>(v);
   }
 
   template <typename T, typename... Ts>
-  inline constexpr T &&get(variant<Ts...> &&v) {
+  KOKKOS_INLINE_FUNCTION constexpr T &&get(variant<Ts...> &&v) {
     return get<detail::find_index_checked<T, Ts...>::value>(lib::move(v));
   }
 
   template <typename T, typename... Ts>
-  inline constexpr const T &get(const variant<Ts...> &v) {
+  KOKKOS_INLINE_FUNCTION constexpr const T &get(const variant<Ts...> &v) {
     return get<detail::find_index_checked<T, Ts...>::value>(v);
   }
 
   template <typename T, typename... Ts>
-  inline constexpr const T &&get(const variant<Ts...> &&v) {
+  KOKKOS_INLINE_FUNCTION constexpr const T &&get(const variant<Ts...> &&v) {
     return get<detail::find_index_checked<T, Ts...>::value>(lib::move(v));
   }
 
   namespace detail {
 
     template <std::size_t I, typename V>
-    inline constexpr /* auto * */ AUTO generic_get_if(V *v) noexcept
+    KOKKOS_INLINE_FUNCTION constexpr /* auto * */ AUTO generic_get_if(V *v) noexcept
       AUTO_RETURN(v && holds_alternative<I>(*v)
                       ? lib::addressof(access::variant::get_alt<I>(*v).value)
                       : nullptr)
@@ -1867,26 +1869,26 @@ namespace mpark {
   }  // namespace detail
 
   template <std::size_t I, typename... Ts>
-  inline constexpr lib::add_pointer_t<variant_alternative_t<I, variant<Ts...>>>
+  KOKKOS_INLINE_FUNCTION constexpr lib::add_pointer_t<variant_alternative_t<I, variant<Ts...>>>
   get_if(variant<Ts...> *v) noexcept {
     return detail::generic_get_if<I>(v);
   }
 
   template <std::size_t I, typename... Ts>
-  inline constexpr lib::add_pointer_t<
+  KOKKOS_INLINE_FUNCTION constexpr lib::add_pointer_t<
       const variant_alternative_t<I, variant<Ts...>>>
   get_if(const variant<Ts...> *v) noexcept {
     return detail::generic_get_if<I>(v);
   }
 
   template <typename T, typename... Ts>
-  inline constexpr lib::add_pointer_t<T>
+  KOKKOS_INLINE_FUNCTION constexpr lib::add_pointer_t<T>
   get_if(variant<Ts...> *v) noexcept {
     return get_if<detail::find_index_checked<T, Ts...>::value>(v);
   }
 
   template <typename T, typename... Ts>
-  inline constexpr lib::add_pointer_t<const T>
+  KOKKOS_INLINE_FUNCTION constexpr lib::add_pointer_t<const T>
   get_if(const variant<Ts...> *v) noexcept {
     return get_if<detail::find_index_checked<T, Ts...>::value>(v);
   }
@@ -1895,7 +1897,7 @@ namespace mpark {
     template <typename RelOp>
     struct convert_to_bool {
       template <typename Lhs, typename Rhs>
-      inline constexpr bool operator()(Lhs &&lhs, Rhs &&rhs) const {
+      KOKKOS_INLINE_FUNCTION constexpr bool operator()(Lhs &&lhs, Rhs &&rhs) const {
         static_assert(std::is_convertible<lib::invoke_result_t<RelOp, Lhs, Rhs>,
                                           bool>::value,
                       "relational operators must return a type"
@@ -1907,7 +1909,7 @@ namespace mpark {
   }  // namespace detail
 
   template <typename... Ts>
-  inline constexpr bool operator==(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator==(const variant<Ts...> &lhs,
                                    const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using equal_to = detail::convert_to_bool<lib::equal_to>;
@@ -1923,7 +1925,7 @@ namespace mpark {
   }
 
   template <typename... Ts>
-  inline constexpr bool operator!=(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator!=(const variant<Ts...> &lhs,
                                    const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using not_equal_to = detail::convert_to_bool<lib::not_equal_to>;
@@ -1939,7 +1941,7 @@ namespace mpark {
   }
 
   template <typename... Ts>
-  inline constexpr bool operator<(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator<(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using less = detail::convert_to_bool<lib::less>;
@@ -1958,7 +1960,7 @@ namespace mpark {
   }
 
   template <typename... Ts>
-  inline constexpr bool operator>(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator>(const variant<Ts...> &lhs,
                                   const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using greater = detail::convert_to_bool<lib::greater>;
@@ -1977,7 +1979,7 @@ namespace mpark {
   }
 
   template <typename... Ts>
-  inline constexpr bool operator<=(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator<=(const variant<Ts...> &lhs,
                                    const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using less_equal = detail::convert_to_bool<lib::less_equal>;
@@ -1997,7 +1999,7 @@ namespace mpark {
   }
 
   template <typename... Ts>
-  inline constexpr bool operator>=(const variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION constexpr bool operator>=(const variant<Ts...> &lhs,
                                    const variant<Ts...> &rhs) {
     using detail::visitation::variant;
     using greater_equal = detail::convert_to_bool<lib::greater_equal>;
@@ -2019,34 +2021,34 @@ namespace mpark {
 
   struct monostate {};
 
-  inline constexpr bool operator<(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator<(monostate, monostate) noexcept {
     return false;
   }
 
-  inline constexpr bool operator>(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator>(monostate, monostate) noexcept {
     return false;
   }
 
-  inline constexpr bool operator<=(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator<=(monostate, monostate) noexcept {
     return true;
   }
 
-  inline constexpr bool operator>=(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator>=(monostate, monostate) noexcept {
     return true;
   }
 
-  inline constexpr bool operator==(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator==(monostate, monostate) noexcept {
     return true;
   }
 
-  inline constexpr bool operator!=(monostate, monostate) noexcept {
+  KOKKOS_INLINE_FUNCTION constexpr bool operator!=(monostate, monostate) noexcept {
     return false;
   }
 
 #ifdef MPARK_CPP14_CONSTEXPR
   namespace detail {
 
-    inline constexpr bool any(std::initializer_list<bool> bs) {
+    KOKKOS_INLINE_FUNCTION constexpr bool any(std::initializer_list<bool> bs) {
       for (bool b : bs) {
         if (b) {
           return true;
@@ -2058,7 +2060,7 @@ namespace mpark {
   }  // namespace detail
 
   template <typename Visitor, typename... Vs>
-  inline constexpr decltype(auto) visit(Visitor &&visitor, Vs &&... vs) {
+  KOKKOS_INLINE_FUNCTION constexpr decltype(auto) visit(Visitor &&visitor, Vs &&... vs) {
     return (!detail::any({vs.valueless_by_exception()...})
                 ? (void)0
                 : throw_bad_variant_access()),
@@ -2069,20 +2071,20 @@ namespace mpark {
   namespace detail {
 
     template <std::size_t N>
-    inline constexpr bool all_impl(const lib::array<bool, N> &bs,
+    KOKKOS_INLINE_FUNCTION constexpr bool all_impl(const lib::array<bool, N> &bs,
                                    std::size_t idx) {
       return idx >= N || (bs[idx] && all_impl(bs, idx + 1));
     }
 
     template <std::size_t N>
-    inline constexpr bool all(const lib::array<bool, N> &bs) {
+    KOKKOS_INLINE_FUNCTION constexpr bool all(const lib::array<bool, N> &bs) {
       return all_impl(bs, 0);
     }
 
   }  // namespace detail
 
   template <typename Visitor, typename... Vs>
-  inline constexpr DECLTYPE_AUTO visit(Visitor &&visitor, Vs &&... vs)
+  KOKKOS_INLINE_FUNCTION constexpr DECLTYPE_AUTO visit(Visitor &&visitor, Vs &&... vs)
     DECLTYPE_AUTO_RETURN(
         (detail::all(
              lib::array<bool, sizeof...(Vs)>{{!vs.valueless_by_exception()...}})
@@ -2093,7 +2095,7 @@ namespace mpark {
 #endif
 
   template <typename... Ts>
-  inline auto swap(variant<Ts...> &lhs,
+  KOKKOS_INLINE_FUNCTION auto swap(variant<Ts...> &lhs,
                    variant<Ts...> &rhs) noexcept(noexcept(lhs.swap(rhs)))
       -> decltype(lhs.swap(rhs)) {
     lhs.swap(rhs);
@@ -2147,7 +2149,7 @@ namespace std {
     using argument_type = mpark::variant<Ts...>;
     using result_type = std::size_t;
 
-    inline result_type operator()(const argument_type &v) const {
+    KOKKOS_INLINE_FUNCTION result_type operator()(const argument_type &v) const {
       using mpark::detail::visitation::variant;
       std::size_t result =
           v.valueless_by_exception()
@@ -2172,7 +2174,7 @@ namespace std {
 #ifndef MPARK_GENERIC_LAMBDAS
     struct hasher {
       template <typename Alt>
-      inline std::size_t operator()(const Alt &alt) const {
+      KOKKOS_INLINE_FUNCTION std::size_t operator()(const Alt &alt) const {
         using alt_type = mpark::lib::decay_t<Alt>;
         using value_type =
             mpark::lib::remove_const_t<typename alt_type::value_type>;
@@ -2191,7 +2193,7 @@ namespace std {
     using argument_type = mpark::monostate;
     using result_type = std::size_t;
 
-    inline result_type operator()(const argument_type &) const noexcept {
+    KOKKOS_INLINE_FUNCTION result_type operator()(const argument_type &) const noexcept {
       return 66740831;  // return a fundamentally attractive random value.
     }
   };
