#
# kharma executable
#
if (Kokkos_ENABLE_CUDA)
    set(EXE_NAME "kharma.cuda")
elseif(Kokkos_ENABLE_SYCL)
    set(EXE_NAME "kharma.sycl")
elseif(Kokkos_ENABLE_HIP)
    set(EXE_NAME "kharma.hip")
else()
    set(EXE_NAME "kharma.host")
endif()

AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR} EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/prob EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/prob/elec EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/prob/emhd EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/prob/utils EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/coordinates EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/flux EXE_NAME_SRC)

AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/b_cd EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/b_cleanup EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/b_ct EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/b_flux_ct EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/boundaries EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/coord_output EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/current EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/driver EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/electrons EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/emhd EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/floors EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/grmhd EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/implicit EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/inverter EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/multizone EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/ismr EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/reductions EXE_NAME_SRC)
AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/wind EXE_NAME_SRC)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/prob)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/prob/elec)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/prob/emhd)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/prob/utils)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/coordinates)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/flux)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/b_cd)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/b_cleanup)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/b_ct)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/b_flux_ct)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/boundaries)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/coord_output)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/current)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/driver)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/electrons)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/emhd)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/floors)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/grmhd)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/implicit)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/inverter)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/multizone)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/ismr)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/reductions)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/wind)

# generate version.cpp file from current git commit in a way that
# 1. Re-generates if hash changes
# 2. Does not re-build everything when hash changes
configure_file("${CMAKE_CURRENT_SOURCE_DIR}/version.cpp.in" "${CMAKE_CURRENT_BINARY_DIR}/version.cpp" @ONLY)
list(APPEND EXE_NAME_SRC "${CMAKE_CURRENT_BINARY_DIR}/version.cpp" version.hpp)

add_executable(${EXE_NAME} ${EXE_NAME_SRC})

target_link_libraries(${EXE_NAME} PUBLIC kokkos)
target_link_libraries(${EXE_NAME} PUBLIC parthenon)
# Sometimes helps with OpenMP
#target_link_libraries(${EXE_NAME} PUBLIC gomp)
target_link_libraries(${EXE_NAME} PUBLIC z)
# Link FFTW3 if available
# Let the code know not to use it otherwise
if (NOT Kokkos_ENABLE_CUDA)
  find_package(FFTW)
  if (FFTW_FOUND)
    target_compile_definitions(${EXE_NAME} PUBLIC USE_FFTW=1)
    target_link_libraries(${EXE_NAME} PUBLIC fftw3)
  else()
    target_compile_definitions(${EXE_NAME} PUBLIC USE_FFTW=0)
    message(WARNING "Cannot find FFTW! Compiling without driven turbulence test.")
  endif()
else()
  target_compile_definitions(${EXE_NAME} PUBLIC USE_FFTW=0)
endif()

# OPTIONS
# These are almost universally performance trade-offs,
# or disabling features that need dependencies.
# TODO is there any way to make compile options less painful in CMake?
option(KHARMA_SPLIT_IMPLICIT_SOLVE "Split the implicit solver kernel into three. Only faster on Frontier, so far" OFF)
option(FAST_CARTESIAN "Break operation in curved spacetimes to make Cartesian Minkowski space computations faster" OFF)
option(KHARMA_DISABLE_IMPLICIT "Disable the implicit solver, which requires bundled kokkos-kernels. Default false" OFF)
option(KHARMA_DISABLE_CLEANUP "Disable the magnetic field cleanup module, which requires recent Parthenon. Default false" OFF)
option(KHARMA_TRACE "Compile with tracing: print entry and exit of important functions. Default false" OFF)

if(KHARMA_SPLIT_IMPLICIT_SOLVE)
    target_compile_definitions(${EXE_NAME} PUBLIC SPLIT_IMPLICIT_SOLVE=1)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC SPLIT_IMPLICIT_SOLVE=0)
endif()
if(FAST_CARTESIAN)
    message("Compiling for Cartesian coordinates only. GRMHD will be disabled!")
    target_compile_definitions(${EXE_NAME} PUBLIC FAST_CARTESIAN=1)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC FAST_CARTESIAN=0)
endif()
if(KHARMA_DISABLE_IMPLICIT)
    message("Compiling without the implicit solver.  Extended GRMHD will be disabled!")
    target_compile_definitions(${EXE_NAME} PUBLIC DISABLE_IMPLICIT=1)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC DISABLE_IMPLICIT=0)
endif()
if(KHARMA_DISABLE_CLEANUP)
    message("Compiling without global Conjugate Gradients.  B field cleanup will be disabled!")
    target_compile_definitions(${EXE_NAME} PUBLIC DISABLE_CLEANUP=1)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC DISABLE_CLEANUP=0)
endif()
# Tracing can be added in the command-line make.sh call: "./make.sh [OPTIONS] trace"
if(KHARMA_TRACE)
    message("Compiling with code tracing (prints 'Flag' calls)")
    target_compile_definitions(${EXE_NAME} PUBLIC TRACE=1)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC TRACE=0)
endif()
if(KHARMA_DISABLE_MPI)
    message("Compiling without MPI!")
    target_compile_definitions(${EXE_NAME} PUBLIC ENABLE_MPI=0)
else()
    target_compile_definitions(${EXE_NAME} PUBLIC ENABLE_MPI=1)
endif()

# FLAGS
if(CMAKE_BUILD_TYPE)
    if(${CMAKE_BUILD_TYPE} STREQUAL "Debug")
        message("Debug build")
        target_compile_definitions(${EXE_NAME} PUBLIC DEBUG=1)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g")
    else()
        message("Explicit non-Debug build")
        target_compile_definitions(${EXE_NAME} PUBLIC DEBUG=0)
    endif()
else()
    message("Implicit non-Debug build")
    target_compile_definitions(${EXE_NAME} PUBLIC DEBUG=0)
endif()

if (Kokkos_ENABLE_HWLOC)
    target_compile_definitions(${EXE_NAME} PUBLIC Kokkos_ENABLE_HWLOC)
    target_link_libraries(${EXE_NAME} PUBLIC hwloc)
endif()
